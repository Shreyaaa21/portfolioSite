<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shreya-Web Developer,Coding Enthusiast</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
    <div class="container">
        <div class="sidebar sidebarGo">
            <nav>
                <ul>
                    <li><a href="/">Home</a></li>
                    <li><a href="/intro.html">My Intro</a></li>
                    <li><a href="/services.html">Services</a></li>
                    <li><a href="/blog.html">Blog</a></li>
                    <li><a href="/contact.html">Contact Me</a></li>
                </ul>
            </nav>
        </div>
        <div class="main">
            <div class="hamburger">
                <img class="ham" src="ham.png" width="30" alt="">
                <img class="cross" src="cross.jpg" width="30" alt="">
            </div>
            <div class="blogContainer">
                <h1>Blogs by Shreya - the developer</h1>
                <div class="blogItem">
                <h2>Learn Javascript-in fun way!</h2>
                <p>As a developer, I naturally want my software to be reliable and responsive. In the early days of my career, feedback on
                my applications was mixed. Some apps scored high praise, but reviews were inconsistent on other apps because they would
                intermittently stop responding midsession—and we all know how little patience end users have for poor program
                responsiveness.
                
                The underlying issue was that the apps were coded using purely synchronous JavaScript. Since JavaScript offers
                (seemingly) asynchronous functions, it’s easy to miss the fact that JavaScript’s runtime itself is synchronous by
                default, and this is a potential pitfall for developers. My curiosity drove me to investigate this programmatic puzzle.</p>
                <button class="btn btn-primary">Read More</button></div>
                <div class="blogItem">
                <h2>The Problem: JavaScript Synchronous Blocking</h2>
                <p>I started my exploration by observing the way that regular, synchronous calls work, focusing my efforts on call
                stacks—last in, first out (LIFO) programming structures.
                
                All call stacks function alike, regardless of the language: We push (add) function calls to the stack and then pop
                (remove) them as needed.</p>
                    <button class="btn btn-primary">Read More</button></div>
                    <div class="blogItem">
                    <h2>The Solution: Asynchronous JavaScript Functionality</h2>
                    <p>Asynchronous coding is a programming technique in which, after we invoke a function, the remainder of our code can run
                    without having to wait for the initial function to return. When an asynchronous task completes, the JavaScript runtime
                    passes the result to a function of our choosing. This method eliminates obstacles for our end users and developers.
                    
                    JavaScript implements asynchronous functionality via a few key architectural components:

</p>
                        <button class="btn btn-primary">Read More</button></div>
                
        </div>
    </div>
    <script src="script.js"></script>
</body>

</html>